 namespace BustaGames.Joystick {    using System;    using UnityEngine;    using UnityEngine.EventSystems;    [RequireComponent(typeof(RectTransform))]    public class Joystick : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler {        private const float ANGLE_THRESHOLD = 22.5f;        private const float VERTICAL_MIN_ANGLE = 90f - ANGLE_THRESHOLD;        private const float VERTICAL_MAX_ANGLE = 90f + ANGLE_THRESHOLD;        private const float HORIZONTAL_MIN_ANGLE = ANGLE_THRESHOLD;        private const float HORIZONTAL_MAX_ANGLE = 180f - ANGLE_THRESHOLD;        public float Horizontal => snapX ? SnapFloat(_input.x, AxisOptions.Horizontal) : _input.x;        public float Vertical => snapY ? SnapFloat(_input.y, AxisOptions.Vertical) : _input.y;        public Vector2 Direction => new Vector2(Horizontal, Vertical);        public bool alwaysVisible;        public float handleRange = 1;        public float deadZone;        public AxisOptions axisOptions = AxisOptions.Both;        public bool snapX;        public bool snapY;        [Space(10f)] // This block is optional                public bool moveToTouch;                [Header("If MoveToTouch")]        public bool returnOnRelease;        public bool followInput;        [Header("If FollowInput")]        public float followThreshold = 1;        [Space(10f)] // End optional block                [SerializeField] private RectTransform background;        [SerializeField] private RectTransform handle;        private bool _isDown;        private bool _hasHandle;        private RectTransform _baseRect;        private Canvas _canvas;        private Camera _camera;                private Vector2 _input = Vector2.zero;        private Vector2 _fixedPosition = Vector2.zero;        private void Awake() {            _baseRect = GetComponent<RectTransform>();            _canvas = GetComponentInParent<Canvas>();            followThreshold = Mathf.Abs(followThreshold);            handleRange = Mathf.Abs(handleRange);            deadZone = Mathf.Abs(deadZone);            if (!moveToTouch) {                followInput = false;                returnOnRelease = false;            }        }        private void Start() {            if (!alwaysVisible)                background.gameObject.SetActive(false);            if (_canvas == null)                Debug.LogError("The Joystick is not placed inside a canvas");            _fixedPosition = background.anchoredPosition;            var center = new Vector2(0.5f, 0.5f);            background.pivot = center;            _hasHandle = handle != null;            if (_hasHandle) {                handle.anchorMin = center;                handle.anchorMax = center;                handle.pivot = center;                handle.anchoredPosition = Vector2.zero;            }        }        public void OnPointerDown(PointerEventData eventData) {            if (moveToTouch) {                background.anchoredPosition = ScreenPointToAnchoredPosition(eventData.position);                if (!alwaysVisible)                    background.gameObject.SetActive(true);            }            OnDrag(eventData);        }        public void OnDrag(PointerEventData eventData) {            _isDown = true;            _camera = null;            if (_canvas.renderMode == RenderMode.ScreenSpaceCamera)                _camera = _canvas.worldCamera;            var position = RectTransformUtility.WorldToScreenPoint(_camera, background.position);            var radius = background.sizeDelta / 2;            _input = (eventData.position - position) / (radius * _canvas.scaleFactor);            FormatInput();            HandleInput(_input.magnitude, _input.normalized, radius);            if (_hasHandle) handle.anchoredPosition = _input * radius * handleRange;        }        public void OnPointerUp(PointerEventData eventData) {            if (!alwaysVisible) background.gameObject.SetActive(false);            if (returnOnRelease) background.anchoredPosition = _fixedPosition;            _isDown = false;            _input = Vector2.zero;            if (_hasHandle) handle.anchoredPosition = Vector2.zero;        }        private void HandleInput(float magnitude, Vector2 normalised, Vector2 radius) {            HandleFollowInput(magnitude, normalised, radius);            if (magnitude > deadZone) {                if (magnitude > 1)                    _input = normalised;            } else {                _input = Vector2.zero;            }        }        private void HandleFollowInput(float magnitude, Vector2 normalised, Vector2 radius) {            if (followInput && magnitude > followThreshold) {                var difference = normalised * (magnitude - followThreshold) * radius;                background.anchoredPosition += difference;            }        }        private void FormatInput() {            switch (axisOptions) {                case AxisOptions.Horizontal:                    _input = new Vector2(_input.x, 0f);                    break;                case AxisOptions.Vertical:                    _input = new Vector2(0f, _input.y);                    break;                case AxisOptions.Both:                    _input = new Vector2(_input.x, _input.y);                    break;                case AxisOptions.None:                    break;                default:                    throw new ArgumentOutOfRangeException();            }        }        private float SnapFloat(float value, AxisOptions snapAxis) {            if (value == 0)                return value;            if (axisOptions == AxisOptions.Both) {                var angle = Vector2.Angle(_input, Vector2.up);                if (snapAxis == AxisOptions.Horizontal) {                    if (angle < HORIZONTAL_MIN_ANGLE || angle > HORIZONTAL_MAX_ANGLE)                        return 0;                    return value > 0 ? 1 : -1;                }                if (snapAxis == AxisOptions.Vertical) {                    if (angle > VERTICAL_MIN_ANGLE && angle < VERTICAL_MAX_ANGLE)                        return 0;                    return value > 0 ? 1 : -1;                }                return value;            }            if (value > 0)                return 1;            if (value < 0)                return -1;            return 0;        }        private Vector2 ScreenPointToAnchoredPosition(Vector2 screenPosition) {            if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(_baseRect, screenPosition, _camera,                out var localPoint))                return Vector2.zero;            var sizeDelta = _baseRect.sizeDelta;            var pivotOffset = _baseRect.pivot * sizeDelta;            return localPoint - background.anchorMax * sizeDelta + pivotOffset;        }    }}